# Variable

## 1 声明一个变量的几种方式

``` go
var a int = 1
var b int // 不赋值默认取零值
var c = 1
d := 1

```

## 2 变量的类型

- 空值: nil
- 整形: int, int8, int16, int32, int64, uint8, uint16...
- 浮点: float32, float64
- 字节类型: byte(等价于uit8)j
- 字符串: string
- 布尔类型: boolean(true or false)

``` go
var a int8 = 10
var c1 byte = 'a'
var b float32 = 12.2
var msg = "hello World"
ok := false

```

## 3. 字符串

字符串使用UTF8编码, 对于英文，每个字符占1字节; 对于中文，一般占3字节.
go 语言中字符串是以byte数组形式保存的，类型是uint8, 占一个byte, 打印时需要用string进行类型转换

``` go
func test_string() {
	var f string = "hello, world"

	fmt.Println(reflect.TypeOf(f[2]), len((f)))
	fmt.Println(string(f))
	fmt.Println(string(f[2]))
}

```

对于包含中文的字符串，正确的处理方式是将string 转为**rune** 数组

``` go
func chinese_language() {
	str2 := "中文chinese language"
	runeArr := []rune(str2)
	fmt.Println(runeArr, string(runeArr[0]), string(runeArr[1]), string(runeArr[2:]))
}

```

转换成`[]rune` 类型后,**字符串中的每个字节，无论占用多少个字节都用int32** 来表示，因而可以正确的处理中文

## 4. 数组(array) 与切片(slice)

声明数组

``` go
var arr [5]int // 声明一维数组
var arr2 [5][5]int // 声明二维数组
var arr = []int{1, 2, 3, 4, 5} // 声明一维数组并初始化, 这里的数组长度可以省略，
arr2 := [2][2]int{{1, 1}, {2, 2}} // 声明二维数组并初始化

```

使用 `[]` 索引或修改数组

``` go
arr3 := []int{1, 2, 3}
for x := 0; x < len(arr3); x++ {
	fmt.Println(arr3[x])
	if x == 2 {
		arr3[2]++
	}

}
fmt.Println(arr3)

```

go语言中，数组的长度不能改变，如果想**拼接两个数组，或是获取子数组** ，需要使用切片，切片是数组的抽象, 切片使用数组作为底层结构. 切片包含三个组件，**容量,长度, 指向底层数组的指针** , 切片可以随时进行扩展

``` go
// 声明切片
slice0 := make([]float32, 0)          // 长度为0
slice1 := make([]float32, 3, 5)       // 长度为3， 容量为5的切片
fmt.Println(len(slice0), cap(slice0)) // 0, 0
fmt.Println(len(slice1), cap(slice1)) // 3 5

// 使用切片
// 添加元素，切片的容量可以根据需要自动扩展
slice1 = append(slice1, 1, 2, 3, 4)
fmt.Println(len(slice1), cap(slice1))
// 子切片
sub1 := slice1[3:] // [1 2 3 4]
sub2 := slice1[:3] // [0 0 0]
// 合并切片
combined := append(sub1, sub2...)
fmt.Println(combined)

```

- 声明切片时可以为切片设置容量大小，为切片预分配空间，在实际使用的过程中，如果容量不够, 切片容量会自动扩展。
- `sub2...` 是切片解构的写法，将切片解构为N个独立的元素.

## 5.字典（map）,使用方式与其他语言类似

``` go
m1 := make(map[string]int) // 仅声明

m2 := map[string]int{ // 声明时初始化
	"Sme": 0,
	"Alice": 1,
}
m1["Tom"] = 18 // 赋值、修改

```

## 6. 指针（pointer）

指针即某个值的**地址**, **类型定义时需要使用符号 `*`**; 
对于一个已经存在的变量，可以使用 `&` 获取该变量的地址.

``` go
str := "Golang"
var p *string = &str // p 是指向 str 的指针
*p = "Hello"
fmt.Println(str) // Hello 修改了 p，str 的值也发生了改变

```

一般来说，指针通常在函数传递参数，或者给某个类型定义新的方法时使用。Go 语言中，参数是按值传递的，如果不使用指针，函数内部将会拷贝一份参数的副本，对参数的修改并不会影响到外部变量的值。如果参数使用指针，对参数的传递将会影响到外部变量。

``` go
func add(num int) {
	num += 1
}

func realAdd(num *int) {
	*num += 1
}

func main() {
	num := 100
	add(num)
	fmt.Println(num)  // 100，num 没有变化

	realAdd(&num)
	fmt.Println(num)  // 101，指针传递，num 被修改
}

```
